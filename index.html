<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 1. Renamed Title -->
    <title>Hall Ticket Schedule Extractor</title>
    
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
</head>
<body class="bg-gray-100 font-sans flex items-center justify-center min-h-screen">

    <!-- Define Python Environment -->
    <py-config>
        <!-- Pinning pdfplumber to a pure-python version to avoid pypdfium2 error -->
        packages = ["pandas", "pdfplumber==0.7.1", "PyPDF2", "pillow"]
    </py-config>

    <div class="container max-w-2xl mx-auto p-4">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full">
            
            <header class="mb-6">
                <!-- 2. Renamed Header -->
                <h1 class="text-3xl font-bold text-gray-800">Hall Ticket Schedule Extractor</h1>
                <p class="text-gray-600 mt-2">
                    Upload your "HT_Third Semester..." PDF file, and this app will run the Python extraction script directly in your browser.
                </p>
            </header>

            <!-- How to Use Instructions -->
            <div class="bg-indigo-50 border border-indigo-200 p-4 rounded-md mb-6">
                <h4 class="font-semibold text-gray-800">How to Use:</h4>
                <ol class="list-decimal list-inside text-sm text-gray-700 mt-2 space-y-1">
                    <li>Select your PDF hall ticket file using the button below.</li>
                    <li>Click 'Run Extraction'.</li>
                    <li>Wait for the processing log to show 'Success!'</li>
                    <li>Click the green 'Download full_schedule.csv' button that appears.</li>
                    <!-- 3. Added new instruction point -->
                    <li>If the log shows a 'Warning: All extraction logic failed...' for a page, that student's data may be missing. Please check the final CSV and add any missing data manually.</li>
                </ol>
                
                <h4 class="font-semibold text-gray-800 mt-4">എങ്ങനെ ഉപയോഗിക്കാം:</h4>
                <ol class="list-decimal list-inside text-sm text-gray-700 mt-2 space-y-1">
                    <li>താഴെയുള്ള ബട്ടൺ ഉപയോഗിച്ച് നിങ്ങളുടെ PDF ഹാൾ ടിക്കറ്റ് ഫയൽ തിരഞ്ഞെടുക്കുക.</li>
                    <li>'Run Extraction' ബട്ടണിൽ ക്ലിക്ക് ചെയ്യുക.</li>
                    <li>പ്രോസസ്സിംഗ് പൂർത്തിയാകുമ്പോൾ ലോഗിൽ 'Success!' എന്ന് കാണുന്നതുവരെ കാത്തിരിക്കുക.</li>
                    <li>അപ്പോൾ പ്രത്യക്ഷപ്പെടുന്ന പച്ച 'Download full_schedule.csv' ബട്ടൺ ക്ലിക്ക് ചെയ്ത് ഫയൽ സേവ് ചെയ്യുക.</li>
                    <!-- 4. Added new instruction point in Malayalam -->
                    <li>ലോഗിൽ ഏതെങ്കിലും പേജിന് 'Warning: All extraction logic failed...' എന്ന് കാണിക്കുകയാണെങ്കിൽ, ആ വിദ്യാർത്ഥിയുടെ ഡാറ്റ അപൂർണ്ണമായിരിക്കാം. ദയവായി CSV ഫയൽ പരിശോധിച്ച്, വിട്ടുപോയ ഡാറ്റ സ്വയം ചേർക്കുക.</li>
                </ol>
            </div>
            <!-- END HOW TO USE SECTION -->

            <!-- Disclaimer -->
            <div class="bg-yellow-50 border border-yellow-300 p-4 rounded-md mb-6">
                <h4 class="font-semibold text-yellow-800">Disclaimer:</h4>
                <p class="text-sm text-yellow-700 mt-2">
                    This tool uses automated logic to extract data. Due to variations in PDF formatting, the extracted data may contain errors or inaccuracies. Please double-check the results for any possible errors.
                </p>
                
                <h4 class="font-semibold text-yellow-800 mt-4">നിരാകരണം:</h4>
                <p class="text-sm text-yellow-700 mt-2">
                    ഈ ടൂൾ ഓട്ടോമേറ്റഡ് ലോജിക് ഉപയോഗിച്ചാണ് ഡാറ്റ വേർതിരിച്ചെടുക്കുന്നത്. PDF ഫോർമാറ്റിംഗിലെ വ്യത്യാസങ്ങൾ കാരണം, എടുത്ത ഡാറ്റയിൽ പിശകുകളോ കൃത്യതക്കുറവോ ഉണ്ടാവാം. ലഭിച്ച ഫലങ്ങൾ നിങ്ങൾ വീണ്ടും പരിശോധിച്ച് ഉറപ്പുവരുത്തുക.
                </p>
            </div>
            <!-- END Disclaimer SECTION -->


            <!-- HTML Interface -->
            <div class="space-y-4">
                <div>
                    <label for="pdf-file" class="block text-sm font-medium text-gray-700">1. Select PDF File:</label>
                    <input type="file" id="pdf-file" accept=".pdf"
                           class="mt-1 block w-full text-sm text-gray-500
                                  file:mr-4 file:py-2 file:px-4
                                  file:rounded-md file:border-0
                                  file:text-sm file:font-semibold
                                  file:bg-indigo-50 file:text-indigo-700
                                  hover:file:bg-indigo-100"/>
                </div>
                
                <button id="run-button" py-click="run_extraction"
                        class="w-full inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-3 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50">
                    2. Run Extraction
                </button>
            </div>

            <!-- Output & Download Area -->
            <div class="mt-6">
                <h3 class="text-lg font-medium text-gray-900">Processing Log:</h3>
                <div id="status" class="w-full h-48 p-3 mt-2 bg-gray-900 text-gray-200 text-sm font-mono rounded-md overflow-y-auto">
                    Waiting for file...
                </div>
            </div>

            <div id="download-area" class="mt-6">
                <!-- The download link will appear here -->
            </div>

        </div>
    </div>

    <!-- The Python Script -->
    <py-script>
        import pandas as pd
        import pdfplumber
        import re
        import io
        from js import document, console, URL, Blob
        import asyncio

        # Get references to our HTML elements
        status_div = document.getElementById("status")
        download_area = document.getElementById("download-area")
        run_button = document.getElementById("run-button")

        def log_message(message):
            """Helper function to print messages to the HTML log."""
            console.log(message)
            # Use single-quotes for the f-string, double-quotes for HTML
            status_div.innerHTML += f'<p class="mb-1">&gt; {message}</p>'
            status_div.scrollTop = status_div.scrollHeight

        async def run_extraction(event):
            """
            This function is called when the "Run Extraction" button is clicked.
            """
            try:
                # Disable button to prevent double-click
                run_button.disabled = True
                download_area.innerHTML = ""
                status_div.innerHTML = ""
                
                log_message("Starting extraction...")

                # 1. Get the file from the HTML input
                file_input = document.getElementById("pdf-file")
                file_list = file_input.files
                
                if file_list.length == 0:
                    log_message("Error: Please select a PDF file first.")
                    run_button.disabled = False
                    return

                file = file_list.item(0)
                log_message(f"Loading file: {file.name}...")

                # 2. Read the file into a Python-readable bytes object
                file_bytes = await file.arrayBuffer()
                pdf_file_obj = io.BytesIO(file_bytes.to_py())

                log_message("File loaded. Processing with pdfplumber...")
                
                all_exam_rows = []
                
                # Regex definitions for "wild card" matching
                code_regex_strict = re.compile(r'^[A-Z]{3,4}\d[A-Z0-9]{3,7}(\(\d\))?$')
                date_regex_strict = re.compile(r'^\d{2}\.\d{2}\.\d{4}$')
                time_regex_strict = re.compile(r'^\d{2}:\d{2}\sPM$')
                
                # Regex for searching *within* cells
                code_regex_search = re.compile(r'[A-Z]{3,4}\d[A-Z0-9]{3,7}(\(\d\))?')
                date_regex_search = re.compile(r'\d{2}\.\d{2}\.\d{4}')
                time_regex_search = re.compile(r'\d{2}:\d{2}\sPM')
                
                # Regex for junk cells to ignore
                slot_regex_strict = re.compile(r'^(Core|Minor|MDC|VAC)\s\d$')
                num_regex_strict = re.compile(r'^\d$') # Matches the '#' column
                
                # Regex to clean time fragments from course names
                time_fragment_cleaner = re.compile(r'\s+\:?\d{2}\sPM$')
                
                reg_num_wildcard = r'VPAY[A-Z]{3}[0-9]{3}'

                # 3. --- Start of PDF processing logic ---
                with pdfplumber.open(pdf_file_obj) as pdf:
                    total_pages = len(pdf.pages)
                    log_message(f"Total pages found: {total_pages}")
                    log_message("Using 'text' alignment strategy for tables.")


                    for i, page in enumerate(pdf.pages):
                        if (i + 1) % 10 == 0 or (i + 1) == total_pages:
                            log_message(f"Processing page {i + 1}/{total_pages}...")
                        
                        page_text = page.extract_text(x_tolerance=1, y_tolerance=1)
                        
                        # --- Find Candidate Name ---
                        name = "Unknown"
                        name_match = re.search(r'Name of Candidate\s*","(.*?)\s*","', page_text, re.DOTALL)
                        if name_match:
                            name = name_match.group(1).strip().replace('\n', ' ')
                        else:
                            name_match_fallback = re.search(r'Name of Candidate\s+(.*?)\s+Date of Birth', page_text)
                            if name_match_fallback:
                                name = name_match_fallback.group(1).strip().replace('\n', ' ')

                        # --- Find Register Number (Robust Logic) ---
                        reg_num = "Unknown"
                        reg_match_label = re.search(r'REGISTER\s*\n*\s*NUMBER\s+([A-Z0-9]+)', page_text, re.DOTALL)
                        if reg_match_label:
                            reg_num = reg_match_label.group(1).strip()
                        else:
                            reg_match_wildcard_match = re.search(reg_num_wildcard, page_text)
                            if reg_match_wildcard_match:
                                reg_num = reg_match_wildcard_match.group(0).strip()
                        
                        # --- Extract Table Data ---
                        tables = page.extract_tables(table_settings={
                            "vertical_strategy": "text",
                            "horizontal_strategy": "lines"
                        })
                        
                        processed_rows_on_page = 0
                        temp_rows_for_page = []
                        
                        # --- LOGIC A: Wild Card (for jumbled PDFs) ---
                        if tables:
                            for table in tables:
                                for row in table:
                                    if not row or not isinstance(row, list):
                                        continue
                                    
                                    course_code = "Unknown"
                                    course_name = "Unknown"
                                    date_val = "Unknown"
                                    time_val = "Unknown"
                                    potential_names = []
                                    found_code = False
                                    found_date = False

                                    row_str = " ".join(filter(None, [c.strip().replace('\n', ' ') if c else '' for c in row]))
                                    
                                    # --- Wildcard Row Validation ---
                                    # A valid row MUST contain a code OR a date
                                    if not (code_regex_search.search(row_str) or date_regex_search.search(row_str)):
                                        continue # This skips headers

                                    for cell in row:
                                        if not cell: continue
                                        cell_text = cell.strip().replace('\n', ' ')
                                        
                                        if code_regex_strict.match(cell_text):
                                            course_code = cell_text
                                            found_code = True
                                        elif date_regex_strict.match(cell_text):
                                            date_val = cell_text
                                            found_date = True
                                        elif time_regex_strict.match(cell_text):
                                            time_val = cell_text
                                        elif date_regex_strict.match(cell_text.split(' ')[0]):
                                            parts = cell_text.split(' ')
                                            date_val = parts[0]
                                            time_val = " ".join(parts[1:])
                                            found_date = True
                                        elif not (slot_regex_strict.match(cell_text) or num_regex_strict.match(cell_text) or cell_text == "Sign"):
                                            potential_names.append(cell_text)
                                    
                                    if found_date and not found_code and potential_names:
                                        for name_cell in potential_names:
                                            code_match = code_regex_search.search(name_cell)
                                            if code_match:
                                                course_code = code_match.group(0)
                                                found_code = True
                                                potential_names.append(name_cell.replace(course_code, '').strip())
                                                break 
                                    
                                    # We *must* have a code and date to proceed
                                    if not (found_code and found_date):
                                        continue

                                    cleaned_names = []
                                    for p_name in potential_names:
                                        p_name_cleaned = p_name.replace(course_code, '').strip()
                                        if p_name_cleaned:
                                            cleaned_names.append(p_name_cleaned)
                                    
                                    if cleaned_names:
                                        course_name = " ".join(cleaned_names) # Join all fragments
                                        # --- Clean time fragments ---
                                        course_name = time_fragment_cleaner.sub('', course_name)
                                    
                                    try:
                                        formatted_row = {
                                            'Date': date_val, 'Time': time_val, 'Course code': course_code,
                                            'Course name': course_name, 'Name of Candidate': name, 'REGISTER NUMBER': reg_num
                                        }
                                        temp_rows_for_page.append(formatted_row)
                                        processed_rows_on_page += 1
                                    except Exception as e:
                                        log_message(f"Warning: Skipping row in Logic A. Details: {e}")
                        
                        # --- CHECK AND RETRY ---
                        if processed_rows_on_page == 0:
                            log_message(f"Warning: Wild card logic failed for page {i + 1}. Retrying with simple column logic...")
                            
                            # --- LOGIC B: Simple Column (for clean PDFs like BA Tamil) ---
                            if tables:
                                for table in tables:
                                    # Simple loop, skip first row (header)
                                    for row in table[1:]: 
                                        try:
                                            if not row or len(row) < 5: continue
                                            
                                            course_code = "Unknown"
                                            course_name = "Unknown"
                                            date_val = "Unknown"
                                            time_val = "Unknown"

                                            # Direct mapping from user's sample
                                            if len(row) == 6: # BA Tamil format
                                                course_code = row[2]
                                                course_name = row[3]
                                                date_val = row[4]
                                                time_val = row[5]
                                            elif len(row) == 5: # B.Com format
                                                course_code = row[2]
                                                course_name = row[3]
                                                date_time_str = row[4].split(' ')
                                                date_val = date_time_str[0]
                                                time_val = " ".join(date_time_str[1:])
                                            else:
                                                continue

                                            # Clean up newlines in all fields
                                            course_code = course_code.strip().replace('\n', ' ') if course_code else "Unknown"
                                            course_name = course_name.strip().replace('\n', ' ') if course_name else "Unknown"
                                            date_val = date_val.strip().replace('\n', ' ') if date_val else "Unknown"
                                            time_val = time_val.strip().replace('\n', ' ') if time_val else "Unknown"
                                            
                                            # --- Clean time fragments ---
                                            course_name = time_fragment_cleaner.sub('', course_name)

                                            # Validate the extracted data
                                            if code_regex_search.search(course_code) and date_regex_search.search(date_val):
                                                formatted_row = {
                                                    'Date': date_val, 'Time': time_val, 'Course code': course_code,
                                                    'Course name': course_name, 'Name of Candidate': name, 'REGISTER NUMBER': reg_num
                                                }
                                                temp_rows_for_page.append(formatted_row)
                                                processed_rows_on_page += 1
                                        except Exception as e:
                                            log_message(f"Skipping row during retry: {e}")
                        
                        # --- END RETRY ---
                        
                        # Add the found rows (from Logic A or B) to the main list
                        all_exam_rows.extend(temp_rows_for_page)
                        
                        if processed_rows_on_page == 0:
                            log_message(f"Warning: All extraction logic failed for page {i + 1} for {name}.")
                            
                # --- End of PDF processing logic ---

                if not all_exam_rows:
                    log_message("Error: No data was extracted. Check PDF format.")
                    run_button.disabled = False
                    return
                
                log_message(f"Processed {total_pages} pages. Found {len(all_exam_rows)} exam entries.")
                log_message("Converting to DataFrame and creating CSV...")

                # 4. Convert to Pandas DataFrame and create CSV string
                df = pd.DataFrame(all_exam_rows)
                df = df[['Date', 'Time', 'Course code', 'Course name', 'Name of Candidate', 'REGISTER NUMBER']]
                csv_data = df.to_csv(index=False, encoding='utf-8')

                # 5. Create a downloadable link for the CSV
                blob = Blob.new([csv_data], {type: "text/csv;charset=utf-8"})
                url = URL.createObjectURL(blob)
                
                download_area.innerHTML = f"""
                    <a href="{url}" download="full_schedule.csv"
                       class="w-full inline-flex justify-center rounded-md border border-transparent bg-green-600 py-3 px-4 text-sm font-medium text-white shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Download full_schedule.csv ({len(all_exam_rows)} rows)
                    </a>
                """
                log_message("Success! Your file is ready for download.")

            except Exception as e:
                log_message(f"An error occurred: {e}")
            
            # Re-enable the button
            run_button.disabled = False
    </py-script>

</body>
</html>

